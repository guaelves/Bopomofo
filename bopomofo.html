<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>注音符號泡泡遊戲</title>
  <style>
    :root{--bg:#f7fbff;--accent:#7cc6ff;--good:#53c28b;--bad:#ff6b6b}
    *{box-sizing:border-box}
    body{font-family: "Microsoft JhengHei", Arial, sans-serif; background:var(--bg); margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center}
    .wrap{width:100%;max-width:1000px;height:760px;background:white;border-radius:18px;box-shadow:0 8px 30px rgba(20,40,80,0.08);padding:20px;display:flex;flex-direction:column;gap:12px;position:relative}
    header{display:flex;align-items:center;justify-content:space-between}
    .title{display:flex;flex-direction:column}
    .title h1{margin:0;font-size:20px}
    .title p{margin:0;color:#666;font-size:14px}
    .target{font-weight:800;font-size:96px;text-align:center;line-height:1;margin:6px 0}
    .target-wrap{display:flex;align-items:center;justify-content:center;flex-direction:column}
    .controls{display:flex;gap:10px;align-items:center}
    button{background:var(--accent);border:none;color:white;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer}
    button.secondary{background:#eee;color:#333}
    .info{color:#444;font-weight:600}

    .play-area{flex:1;background:linear-gradient(180deg,#ffffff, #f2f8ff);border-radius:12px;position:relative;overflow:hidden;border:1px solid rgba(0,0,0,0.03)}
    .bubble{position:absolute;border-radius:50%;display:flex;align-items:center;justify-content:center;cursor:pointer;user-select:none;transition:transform .25s ease,opacity .25s ease;box-shadow:0 6px 14px rgba(20,30,80,0.08);border:3px solid rgba(255,255,255,0.6);background:rgba(255,255,255,0.85);}
    .bubble.correct{background:linear-gradient(135deg,#d2ffd9,#b5f0d0);border-color:rgba(0,0,0,0.04);}
    .bubble.wrong{animation:pop .45s forwards}
    @keyframes pop{0%{transform:scale(1);opacity:1}70%{transform:scale(.8);opacity:1}100%{transform:scale(0.2);opacity:0}}
    .bubble.outline{border:2px dashed rgba(0,0,0,0.15);background:transparent}

    .footer{display:flex;align-items:center;justify-content:space-between}
    .status{color:#555}
    .big{font-weight:800}
    /* responsive */
    @media(max-width:600px){.target{font-size:80px}.wrap{height:calc(100vh - 40px);max-width:420px}}
  </style>
</head>
<body>
  <div class="wrap" role="application">
    <header>
      <div class="title">
        <h1>注音符號泡泡遊戲</h1>
        <p>題目會顯示一個注音，點選對應的泡泡（共 10 題）</p>
      </div>
      <div class="controls">
        <div class="info">題數 <span id="qnum">0</span>/10</div>
        <button id="restart">重新開始</button>
      </div>
    </header>

    <div class="target-wrap">
      <div id="target" class="target" aria-live="polite">-</div>
      <div style="display:flex;gap:10px;align-items:center;">
        <button class="secondary" id="playSound">播放聲音</button>
        <div class="status">答對數 <span id="score">0</span></div>
      </div>
    </div>

    <section class="play-area" id="playArea" aria-label="遊戲畫面">
      <!-- bubbles appended here -->
    </section>

    <div class="footer">
      <div class="status">提示：泡泡字體至少 40px，大小不一、位置不重疊。正確變彩色，錯誤會破掉。</div>
      <div class="status">作者：ChatGPT</div>
    </div>
  </div>

  <script>
    // 注音符號清單
    const initials = ['ㄅ','ㄆ','ㄇ','ㄈ','ㄉ','ㄊ','ㄋ','ㄌ','ㄍ','ㄎ','ㄏ','ㄐ','ㄑ','ㄒ','ㄓ','ㄔ','ㄕ','ㄖ','ㄗ','ㄘ','ㄙ'];
    const medials = ['ㄧ','ㄨ','ㄩ'];
    const finals = ['ㄚ','ㄛ','ㄜ','ㄝ','ㄞ','ㄟ','ㄠ','ㄡ','ㄢ','ㄣ','ㄤ','ㄥ','ㄦ'];
    const pool = [...initials, ...medials, ...finals];

    const playArea = document.getElementById('playArea');
    const targetEl = document.getElementById('target');
    const qnumEl = document.getElementById('qnum');
    const scoreEl = document.getElementById('score');
    const restartBtn = document.getElementById('restart');
    const playSoundBtn = document.getElementById('playSound');

    let questions = [];
    let current = 0;
    let score = 0;
    let busy = false;

    function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}

    function makeQuestions(){
      // 從 pool 隨機抽 10 題（可重複或不重複？這裡不重複）
      const copy = [...pool];
      shuffle(copy);
      return copy.slice(0,10);
    }

    // 為發聲準備（用簡單的示例發音）
    // 將注音轉成可發聲的音節（大致對應）
    const zhuyinToSyllable = {
      // initials (搭配 a)
      'ㄅ':'ba','ㄆ':'pa','ㄇ':'ma','ㄈ':'fa','ㄉ':'da','ㄊ':'ta','ㄋ':'na','ㄌ':'la','ㄍ':'ga','ㄎ':'ka','ㄏ':'ha','ㄐ':'ji','ㄑ':'qi','ㄒ':'xi','ㄓ':'zhi','ㄔ':'chi','ㄕ':'shi','ㄖ':'ri','ㄗ':'zi','ㄘ':'ci','ㄙ':'si',
      // medials
      'ㄧ':'yi','ㄨ':'wu','ㄩ':'yu',
      // finals (standalone vowels)
      'ㄚ':'a','ㄛ':'o','ㄜ':'e','ㄝ':'ê','ㄞ':'ai','ㄟ':'ei','ㄠ':'ao','ㄡ':'ou','ㄢ':'an','ㄣ':'en','ㄤ':'ang','ㄥ':'eng','ㄦ':'er'
    };

    function speak(text){
      if(!('speechSynthesis' in window)) return;
      const ut = new SpeechSynthesisUtterance(text);
      ut.lang = 'zh-TW';
      // try to pick a zh-TW voice
      const voices = speechSynthesis.getVoices();
      const v = voices.find(x=>x.lang.includes('TW')) || voices.find(x=>x.lang.includes('zh'))||voices[0];
      if(v) ut.voice=v;
      ut.rate = 0.9;
      speechSynthesis.cancel();
      speechSynthesis.speak(ut);
    }

    // 簡單的音效（using WebAudio）
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audiocontext = AudioCtx ? new AudioCtx() : null;
    function beep(freq, duration=0.12){
      if(!audiocontext) return;
      const o = audiocontext.createOscillator();
      const g = audiocontext.createGain();
      o.type='sine'; o.frequency.value=freq; g.gain.value=0.04;
      o.connect(g); g.connect(audiocontext.destination);
      o.start(); o.stop(audiocontext.currentTime + duration);
    }

    function placeBubbles(correctSymbol){
      playArea.innerHTML='';
      const areaRect = playArea.getBoundingClientRect();
      const bubbles = [];
      // we will create between 8 and 12 bubbles
      const count = 10; // fixed 10 for ample choices
      // ensure at least one correct bubble and several wrong
      const choices = new Set();
      choices.add(correctSymbol);
      while(choices.size < count){
        const pick = pool[Math.floor(Math.random()*pool.length)];
        choices.add(pick);
      }
      const arr = shuffle(Array.from(choices));

      // simple non-overlap placement
      function rand(min,max){return Math.floor(Math.random()*(max-min+1))+min}
      function overlaps(x,y,r,others){
        for(const o of others){
          const dx = x - o.x; const dy = y - o.y; const dist = Math.sqrt(dx*dx+dy*dy);
          if(dist < r + o.r + 6) return true;
        }
        return false;
      }

      for(const sym of arr){
        const font = rand(40,64); // at least 40px
        const diameter = Math.max(80, font*2 + rand(-10,50));
        const r = diameter/2;
        let x,y,attempt=0;
        do{
          x = rand(r+8, Math.max(r+8, areaRect.width - r - 8));
          y = rand(r+8, Math.max(r+8, areaRect.height - r - 8));
          attempt++;
          if(attempt>400) break;
        } while(overlaps(x,y,r,bubbles));
        bubbles.push({sym,x,y,r,font,diameter});
      }

      // render bubbles
      for(const b of bubbles){
        const el = document.createElement('div');
        el.className='bubble';
        el.style.width = b.diameter+'px';
        el.style.height = b.diameter+'px';
        el.style.left = (b.x - b.r) + 'px';
        el.style.top = (b.y - b.r) + 'px';
        el.style.fontSize = b.font + 'px';
        el.textContent = b.sym;
        el.setAttribute('role','button');
        el.setAttribute('aria-label', '選項 '+b.sym);
        // event
        el.addEventListener('click', ()=>onBubbleClick(el,b.sym));
        playArea.appendChild(el);
      }
    }

    function onBubbleClick(el, sym){
      if(busy) return;
      const targetSym = questions[current];
      if(sym === targetSym){
        busy = true;
        el.classList.add('correct');
        el.style.transform = 'scale(1.06)';
        beep(880,0.12);
        score++;
        scoreEl.textContent = score;
        // small celebration (confetti-ish using CSS simple)
        setTimeout(()=>{
          current++;
          qnumEl.textContent = current;
          if(current >= questions.length){
            targetEl.textContent = '完成！';
            speak('恭喜，全部完成');
            busy=false;
            return;
          }
          showQuestion(current);
          busy=false;
        }, 600);
      } else {
        // wrong: make it pop and leave dashed outline
        el.classList.add('wrong');
        beep(220,0.15);
        setTimeout(()=>{
          // replace with outline left in place
          el.classList.remove('wrong');
          el.classList.add('outline');
          el.style.opacity = '0.9';
          el.style.transform = 'scale(1)';
          el.style.pointerEvents = 'none';
        }, 460);
      }
    }

    function showQuestion(index){
      const sym = questions[index];
      targetEl.textContent = sym;
      targetEl.style.fontSize = '96px';
      qnumEl.textContent = index+1;
      placeBubbles(sym);
      // speak the symbol using mapping
      const syll = zhuyinToSyllable[sym] || sym;
      // for better clarity speak full phrase
      speak(syll);
    }

    function startGame(){
      speechSynthesis.cancel();
      questions = makeQuestions();
      current = 0; score = 0; busy=false;
      scoreEl.textContent = score;
      qnumEl.textContent = 0;
      setTimeout(()=>{
        showQuestion(0);
        qnumEl.textContent = 1;
      }, 120);
    }

    restartBtn.addEventListener('click', ()=>{
      startGame();
    });

    playSoundBtn.addEventListener('click', ()=>{
      const sym = questions[current];
      if(sym) speak(zhuyinToSyllable[sym] || sym);
    });

    // 初始化
    startGame();

    // accessibility: keyboard support (arrow keys move focus between bubbles)
    document.addEventListener('keydown', (e)=>{
      if(e.key === ' '){ e.preventDefault(); const focused = document.activeElement; if(focused && focused.classList.contains('bubble')) focused.click(); }
    });

    // resize handling: remake bubbles when window resizes to avoid overlap issues
    let resizeTimer;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=>{ if(questions.length) showQuestion(current); }, 300);
    });

  </script>
</body>
</html>

